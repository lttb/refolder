/* @flow */

import React, {Component, PureComponent, type ElementProps, type Node} from 'react'


export class $React$Component<T, State = {}> extends Component<$PropertyType<T, 'props'>, State> {
  $: T;

  // of(fn) {
  //   return fn.bind(this.$)
  // }
}

class Test<T: {C: ComponentType<*>}> extends Component<T> {
  render() {
    const {C, ...props} = this.props

    return <C {...props} />
  }
}

function rndr<T>(x: T) {
  declare class L extends Test<T> {}

  return <L {...x} />
}

declare function apply<Fn, Fs, F1, F2, F3, F4, F5>(Fn, Fs): $Call<(
    & (([F1]) => $Call<Fn, F1>)
    & (([F1, F2]) => $Call<Fn, F1, F2>)
    & (([F1, F2, F3]) => $Call<Fn, F1, F2, F3>)
    & (([F1, F2, F3, F4]) => $Call<Fn, F1, F2, F3, F4>)
    & (([F1, F2, F3, F4, F5]) => $Call<Fn, F1, F2, F3, F4, F5>)
), Fs>

type Apply<Fn, Fs> = $Call<typeof apply, Fn, Fs>


// type Mapper<F> = $TupleMap<F, <C, A, X, V: (
//   | ({props: (A => Node) => (X) => Node})
//   | ((string) => {props: (A => Node) => (X) => Node})
// )>(V) => ((X) => A)>

type Mapper<F> = $TupleMap<F, (
  & (<A, C, V: {props: (A => Node) => ($PropertyType<C, 'props'>) => Node}>(V) => ((C) => ({
    ...$Exact<C>,
    ...$Exact<V>,
    props: A
  })))
  & (<A, C, V: {props: (A => Node) => ($PropertyType<C, 'props'>) => Node}>(C => V) => ((C) => {
    ...$Exact<C>,
    ...$Exact<V>,
    props: A
  }))
)>

declare function f<$, F>(...folders: F): ({
  of: (any) => Class<React$Component<{lol: 'lol'}>>,
  [[call]]: (<B>(Base: *) =>
    Class<$React$Component<{
      ...$Exact<B>,
      ...$Exact<$ObjMap<$Call<Apply<
        $ComposeReverse,
        Mapper<F>,
      >, ({props: *})>, <V>(V) => V>>,
    }, void>>)
})


export default f
