/* @flow */

declare function apply<Fn, Fs, F1, F2, F3, F4, F5>(Fn, Fs): $Call<(
    & (([F1]) => $Call<Fn, F1>)
    & (([F1, F2]) => $Call<Fn, F1, F2>)
    & (([F1, F2, F3]) => $Call<Fn, F1, F2, F3>)
    & (([F1, F2, F3, F4]) => $Call<Fn, F1, F2, F3, F4>)
    & (([F1, F2, F3, F4, F5]) => $Call<Fn, F1, F2, F3, F4, F5>)
), Fs>

type Apply<Fn, Fs> = $Call<typeof apply, Fn, Fs>

type Mapper<F> = $TupleMap<F, (
  & (<A, C, V: {props: (A => Node) => ($PropertyType<C, 'props'>) => Node}>(V) => ((C) => ({
    ...$Exact<C>,
    ...$Exact<V>,
    props: A
  })))
  & (<A, C, V: {props: (A => Node) => ($PropertyType<C, 'props'>) => Node}>(C => V) => ((C) => {
    ...$Exact<C>,
    ...$Exact<V>,
    props: A
  }))
)>

declare function f<$, F>(...folders: F): ({
  of: (any) => Class<React$Component<{lol: 'lol'}>>,
  [[call]]: (<B>(Base: B) => (
    $Call<Apply<
      $ComposeReverse,
      F,
    >, B>
  ))
})

export default f
