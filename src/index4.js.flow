/* @flow */

import {Component} from 'react'

// declare function apply<Fn, Fs, F1, F2, F3, F4, F5>(Fn, Fs): $Call<(
//     & (([F1, F2, F3, F4, F5]) => $Call<Fn, F1, F2, F3, F4, F5>)
//     & (([F1, F2, F3, F4]) => $Call<Fn, F1, F2, F3, F4>)
//     & (([F1, F2, F3]) => $Call<Fn, F1, F2, F3>)
//     & (([F1, F2]) => $Call<Fn, F1, F2>)
//     & (([F1]) => $Call<Fn, F1>)
// ), Fs>
//
// type Apply<Fn, Fs> = $Call<typeof apply, Fn, Fs>

function F1<T>(_) {
  return class heh<T> extends _<T> {
    self: {x: 1}
  }
}

class OH<T> {
  props: T
}

type OOH = typeof OH

declare function F3<T, A>(_: T, x: A): T

declare function F2<B, T>(B, T): $Call<typeof F3, B, T>

type HAH<F, B, T> = $Call<typeof F2, $Call<Apply<
  $ComposeReverse,
  F,
>, $Call<typeof F1, B, T>>, T>

// const LOLKA = <X>(_: X) => class $0<T: {}, S> extends _<{|...$Exact<T>|}> {
//   self: {...$Exact<S>}
// }

declare class T_T<T: {}, S> extends _<{|...$Exact<T>|}> {
  self: {...$Exact<S>}
}

function LOLKA(_) {
  return class $0<T: {}, S> extends _<{|...$Exact<T>|}> {
    props: {|...$Exact<T>|}
    self: {...$Exact<S>}
  }
}


const x = _ => _

// declare function concat<A, B, X1, X2, X3, Y1, Y2, Y3, Y4, Y5>(A, B): $Call<(
//     & (([F1, F2, F3, F4, F5]) => $Call<Fn, F1, F2, F3, F4, F5>)
//     & (([F1, F2, F3, F4]) => $Call<Fn, F1, F2, F3, F4>)
//     & (([F1, F2, F3]) => $Call<Fn, F1, F2, F3>)
//     & (([F1, F2]) => $Call<Fn, F1, F2>)
//     & (([F1]) => $Call<Fn, F1>)
// ), A, B>

function LOLKA2(_, P) {
  return class $0<T = {}, S = {}> extends _<{|...$Exact<T>|}, S> {
    props: {|...$Exact<T>|}
  }
}

// type Mapper<F> = $TupleMap<F, (
//   & (<C, L: $PropertyType<C, 'lift'>, P: $Call<<T>((T => any) => any) => T, L>>(C => any) => $Call<typeof LOLKA2, C, P>)
//   & (<V>(V) => V)
// )>

// type Mapper<F> = $TupleMap<F, (
//   & (<T, C, R, V: (C) => Class<R>, P1>(V) => ({class: C, props: P1}) => ({
//     props: {...$Exact<P1>, ...$Exact<$Call<((T => any) => any) => T, $PropertyType<R, 'lift'>>>},
//     class: Class<R>,
//   }))
// )>

// type Mapper<F> = $TupleMap<F, (
//   & (<C0, R0, C: Class<C0>, R: Class<R0>, V: (C) => R, P1>(V) => ({class: C, props: P1}) => ({
//     props: P1,
//     class: R,
//   }))
// )>

declare function tt<T>(T): T

type Mapper<F> = $TupleMap<F, (
  & (<T, C0, R0, C: Class<C0>, R: Class<R0>, V: (C) => R, P1>(V) => ({class: C, props: P1}) => ({
    props: {...$Exact<P1>, ...$Exact<$Call<((T => any) => any) => T, $PropertyType<R0, 'lift'>>>},
    class: R & {props: {...$Exact<P1>, ...$Exact<$Call<((T => any) => any) => T, $PropertyType<R0, 'lift'>>>}},
  }))
  & (<V>(V) => V)
)>


// type Mapper<F> = $TupleMap<F, (
//   & (<T, C0, R0, C: Class<C0>, R: Class<R0>, V: (C) => R, P1>(V) => $Call<((T => any) => any) => T, $PropertyType<C0, 'lift'>>)
// )>

// declare function f<$, F>(...folders: F): ({
//   // test: $ElementType<Mapper<F>, 0>,
//   [[call]]: (<T, B>(Base: B) => (
//     $PropertyType<$Call<Apply<
//       $ComposeReverse,
//       // Mapper<F>,
//       Mapper<F>,
//     >, {class: $Call<typeof LOLKA, B>, props: {}}>, 'class'>
//   ))
// })

const init = _ => class $<T> extends (class extends _<any> {}) {props: T}

function LOLKACast(_) {
  return class $0<T = {}, S = {}> extends _<{|...$Exact<T>|}, S> {
    props: any
  }
}

// type Caster<F> = $Call<
//   Apply<
//     $Compose,
//     $TupleMap<F, <A, R, V: A => R>(V) => (A => R)>
//   >
// >

const cast = _ => class $<T> extends (class extends _ {props: any}) {props: T}

type _Cast = typeof cast

class Kek<T> extends Component<T> {}

class X<P, S = any> { props: P; self: S }
class Y<T> { props: T}

const xx = <T: *, P>(_: Class<T>): $Supertype<Class<X<P> & T>> => class extends _ {prop: any}
// const yy = (_) => class $<A> extends _ {props: A}
const yy = <T: *, P>(_: Class<T>) => class $<A: P> extends _ {props: A}

declare function xxx<T: *, C: Class<T>>(_: C): $Call<$Call<$Compose, typeof yy, typeof xx>, C>

type Caster<F> = $TupleMap<F, (
  & (<A, R, V: A => R, X: $Call<typeof cast, A>>(V) => (
    // & (A => null)
    // & (A => R)
    // & ($Call<$Compose, V, typeof xx>)
    V
  ))
)>

const kk = _ => class extends _<any> {}

declare function $$<A, R>(A => R): (
  <X>(X) => ($Call<$Call<$Compose, typeof xx, (A => R)>, X>)
)
type _$$<T> = $Call<typeof $$, T>

// declare function f<$, F>(...folders: F): ({
//   // test: $ElementType<Mapper<F>, 0>,
//   [[call]]: (<T, B>(Base: B) => (
//     $Call<
//       Apply<$ComposeReverse, F>,
//       B,
//       // $Call<typeof xx, B>,
//       // $Call<typeof LOLKA, B>
//     >
//   ))
// })

class O<Enhance, Base, S = any> {
  props: {|...Enhance|};
  self: S;
  $props: {|...Base|};
}

const of = <T: *>(_: Class<T>): $Supertype<
  Class<O<$PropertyType<T, 'props'>, $PropertyType<T, '$props'>>
  & T
>> => class extends _ {props: any; $props: any}

type _of = typeof of

declare function $$$<A, R>(A => R): (
  <X>(X) => (
    $Call<$Call<$Compose, _of, (A => R)>, X>
  )
)

type _$$$<T> = $Call<typeof $$$, T>

/* eslint-disable no-redeclare */

declare function f<$, A1>(A1): (<B>(Base: B) => (
  $Call<$Call<$ComposeReverse, A1>, B>
))
declare function f<$, A1, A2>(A1, A2): (<B>(Base: B) => (
  $Call<$Call<$ComposeReverse, A1, A2>, B>
))
declare function f<$, A1, A2, A3>(A1, A2, A3): (<B>(Base: B) => (
  $Call<$Call<$ComposeReverse, A1, A2, A3>, B>
))
declare function f<$, A1, A2, A3, A4>(A1, A2, A3, A4): (<B>(Base: B) => (
  $Call<$Call<$ComposeReverse, A1, A2, A3, A4>, B>
))
declare function f<$, A1, A2, A3, A4, A5>(A1, A2, A3, A4, A5): (<B>(Base: B) => (
  $Call<$Call<$ComposeReverse, A1, A2, A3, A4, A5>, B>
))

// declare function apply<Fn, A1, A2, A3>(Fn, [A1, A2, A3]): $Call<Fn, A1, A2, A3>
// declare function apply<Fn, A1, A2>(Fn, [A1, A2]): $Call<Fn, A1, A2>

// type apply = (
//   & <Fn, A1, A2, A3>([A1, A2, A3]) => $Call<$ComposeReverse, A1, A2, A3>
//   & <Fn, A1, A2>([A1, A2]) => $Call<$ComposeReverse, A1, A2>
//   & <Fn, A1>([A1]) => $Call<$ComposeReverse, A1>
// )



// declare function apply<B, A1, A2, A3>(
//   [A1, A2, A3]
// ): $Call<$Call<$ComposeReverse, A1, A2, A3>, B>
// declare function apply<B, A1, A2, A3, A4>(
//   [A1, A2, A3, A4]
// ): $Call<$Call<$ComposeReverse, A1, A2, A3, A4>, B>
// declare function apply<B, A1, A2, A3, A4, A5>(
//   [A1, A2, A3, A4, A5]
// ): $Call<$Call<$ComposeReverse, A1, A2, A3, A4, A5>, B>
//
// // declare function apply<B, A1, A2>(
// //   [A1, A2]
// // ): $Call<$Call<$ComposeReverse, A1, A2>, B>
// // declare function apply<B, A1>(
// //   [A1]
// // ): $Call<$Call<$ComposeReverse, A1>, B>
//
// declare function f<$, F>(...folders: F): ({
//   [[call]]: (<T, B>(Base: B) => (
//     $Call<typeof apply, $TupleMap<F, <V>(V) => V>, B>
//   ))
// })

// declare var f: $ComposeReverse

export default f
