/* @flow */

declare function apply<Fn, Fs, F1, F2, F3, F4, F5>(Fn, Fs): $Call<(
    & (([F1, F2, F3, F4, F5]) => $Call<Fn, F1, F2, F3, F4, F5>)
    & (([F1, F2, F3, F4]) => $Call<Fn, F1, F2, F3, F4>)
    & (([F1, F2, F3]) => $Call<Fn, F1, F2, F3>)
    & (([F1, F2]) => $Call<Fn, F1, F2>)
    & (([F1]) => $Call<Fn, F1>)
), Fs>

type Apply<Fn, Fs> = $Call<typeof apply, Fn, Fs>

function F1<T>(_) {
  return class heh<T> extends _<T> {
    self: {x: 1}
  }
}

class OH<T> {
  props: T
}

type OOH = typeof OH

declare function F3<T, A>(_: T, x: A): T

declare function F2<B, T>(B, T): $Call<typeof F3, B, T>

type HAH<F, B, T> = $Call<typeof F2, $Call<Apply<
  $ComposeReverse,
  F,
>, $Call<typeof F1, B, T>>, T>

// const LOLKA = <X>(_: X) => class $0<T: {}, S> extends _<{|...$Exact<T>|}> {
//   self: {...$Exact<S>}
// }

declare class T_T<T: {}, S> extends _<{|...$Exact<T>|}> {
  self: {...$Exact<S>}
}

function LOLKA(_) {
  return class $0<T: {}, S> extends _<{|...$Exact<T>|}> {
    props: {|...$Exact<T>|}
    self: {...$Exact<S>}
  }
}


const x = _ => _

// declare function concat<A, B, X1, X2, X3, Y1, Y2, Y3, Y4, Y5>(A, B): $Call<(
//     & (([F1, F2, F3, F4, F5]) => $Call<Fn, F1, F2, F3, F4, F5>)
//     & (([F1, F2, F3, F4]) => $Call<Fn, F1, F2, F3, F4>)
//     & (([F1, F2, F3]) => $Call<Fn, F1, F2, F3>)
//     & (([F1, F2]) => $Call<Fn, F1, F2>)
//     & (([F1]) => $Call<Fn, F1>)
// ), A, B>

function LOLKA2(_, P) {
  return class $0<T = {}, S = {}> extends _<{|...$Exact<T>|}, S> {
    props: {|...$Exact<T>|}
  }
}

// type Mapper<F> = $TupleMap<F, (
//   & (<C, L: $PropertyType<C, 'lift'>, P: $Call<<T>((T => any) => any) => T, L>>(C => any) => $Call<typeof LOLKA2, C, P>)
//   & (<V>(V) => V)
// )>

// type Mapper<F> = $TupleMap<F, (
//   & (<T, C, R, V: (C) => Class<R>, P1>(V) => ({class: C, props: P1}) => ({
//     props: {...$Exact<P1>, ...$Exact<$Call<((T => any) => any) => T, $PropertyType<R, 'lift'>>>},
//     class: Class<R>,
//   }))
// )>

// type Mapper<F> = $TupleMap<F, (
//   & (<C0, R0, C: Class<C0>, R: Class<R0>, V: (C) => R, P1>(V) => ({class: C, props: P1}) => ({
//     props: P1,
//     class: R,
//   }))
// )>

declare function tt<T>(T): T

type Mapper<F> = $TupleMap<F, (
  & (<T, C0, R0, C: Class<C0>, R: Class<R0>, V: (C) => R, P1>(V) => ({class: C, props: P1}) => ({
    props: {...$Exact<P1>, ...$Exact<$Call<((T => any) => any) => T, $PropertyType<R0, 'lift'>>>},
    class: R & {props: {...$Exact<P1>, ...$Exact<$Call<((T => any) => any) => T, $PropertyType<R0, 'lift'>>>}},
  }))
  & (<V>(V) => V)
)>


// type Mapper<F> = $TupleMap<F, (
//   & (<T, C0, R0, C: Class<C0>, R: Class<R0>, V: (C) => R, P1>(V) => $Call<((T => any) => any) => T, $PropertyType<C0, 'lift'>>)
// )>

// declare function f<$, F>(...folders: F): ({
//   // test: $ElementType<Mapper<F>, 0>,
//   [[call]]: (<T, B>(Base: B) => (
//     $PropertyType<$Call<Apply<
//       $ComposeReverse,
//       // Mapper<F>,
//       Mapper<F>,
//     >, {class: $Call<typeof LOLKA, B>, props: {}}>, 'class'>
//   ))
// })

declare function f<$, F>(...folders: F): ({
  // test: $ElementType<Mapper<F>, 0>,
  [[call]]: (<T, B>(Base: B) => (
    $Call<
      Apply<$ComposeReverse, F>,
      B,
      // $Call<typeof LOLKA, B>
    >
  ))
})

// declare var f: $ComposeReverse

export default f
